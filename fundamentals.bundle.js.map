{"version":3,"file":"fundamentals.bundle.js","mappings":"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","sources":["webpack://dice-webgl-renderer/webpack/bootstrap","webpack://dice-webgl-renderer/./src/webglUtils.ts","webpack://dice-webgl-renderer/./src/fundamentals.ts"],"sourcesContent":["// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/**\n * Resize a canvas to match the size its displayed.\n * @param {HTMLCanvasElement} canvas The canvas to resize.\n * @param {number} [multiplier] amount to multiply by.\n *    Pass in window.devicePixelRatio for native pixels.\n * @return {boolean} true if the canvas was resized.\n * @memberOf module:webgl-utils\n */\nexport const resizeCanvasToDisplaySize = (\n  canvas: HTMLCanvasElement,\n  multiplier: number\n): boolean => {\n  multiplier = multiplier || 1\n  const width = (canvas.clientWidth * multiplier) | 0\n  const height = (canvas.clientHeight * multiplier) | 0\n  if (canvas.width !== width || canvas.height !== height) {\n    canvas.width = width\n    canvas.height = height\n    return true\n  }\n  return false\n}\n\nexport const observeAndResizeCanvas = (\n  canvas: HTMLCanvasElement,\n  initialSize: [number, number]\n): CanvasResizer => {\n  // init with the default canvas size\n  const canvasToDisplaySizeMap: Map<Element, number[]> = new Map([\n    [canvas, initialSize],\n  ])\n\n  const onResize = (entries: any[]) => {\n    for (const entry of entries) {\n      let width\n      let height\n      let dpr = window.devicePixelRatio\n      if (entry.devicePixelContentBoxSize) {\n        // NOTE: Only this path gives the correct answer\n        // The other paths are imperfect fallbacks\n        // for browsers that don't provide anyway to do this\n        width = entry.devicePixelContentBoxSize[0].inlineSize\n        height = entry.devicePixelContentBoxSize[0].blockSize\n        dpr = 1 // it's already in width and height\n      } else if (entry.contentBoxSize) {\n        if (entry.contentBoxSize[0]) {\n          width = entry.contentBoxSize[0].inlineSize\n          height = entry.contentBoxSize[0].blockSize\n        } else {\n          width = entry.contentBoxSize.inlineSize\n          height = entry.contentBoxSize.blockSize\n        }\n      } else {\n        width = entry.contentRect.width\n        height = entry.contentRect.height\n      }\n      const displayWidth = Math.round(width * dpr)\n      const displayHeight = Math.round(height * dpr)\n      canvasToDisplaySizeMap.set(entry.target, [displayWidth, displayHeight])\n    }\n  }\n\n  const resizeObserver = new ResizeObserver(onResize)\n  resizeObserver.observe(canvas, { box: 'content-box' })\n\n  const resizeCanvasToDisplaySize = (): boolean => {\n    // Get the size the browser is displaying the canvas in device pixels.\n    const [displayWidth, displayHeight] = canvasToDisplaySizeMap.get(canvas)\n\n    // Check if the canvas is not the same size.\n    const needResize =\n      canvas.width !== displayWidth || canvas.height !== displayHeight\n\n    if (needResize) {\n      // Make the canvas the same size\n      canvas.width = displayWidth\n      canvas.height = displayHeight\n    }\n    return needResize\n  }\n\n  return { resizeCanvasToDisplaySize }\n}\n\nexport type CanvasResizer = {\n  resizeCanvasToDisplaySize: () => boolean\n}\n\nconst createShader = (\n  gl: WebGL2RenderingContext,\n  type: number,\n  source: string\n): WebGLShader => {\n  const shader = gl.createShader(type)\n  gl.shaderSource(shader, source)\n  gl.compileShader(shader)\n  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\n  if (success) {\n    return shader\n  }\n\n  console.log(gl.getShaderInfoLog(shader))\n  gl.deleteShader(shader)\n}\n\nconst createProgram = (\n  gl: WebGL2RenderingContext,\n  shaders: [WebGLShader, WebGLShader]\n): WebGLProgram => {\n  const [vertexShader, fragmentShader] = shaders\n\n  const program = gl.createProgram()\n  gl.attachShader(program, vertexShader)\n  gl.attachShader(program, fragmentShader)\n  gl.linkProgram(program)\n  const success = gl.getProgramParameter(program, gl.LINK_STATUS)\n  if (success) {\n    return program\n  }\n\n  console.log(gl.getProgramInfoLog(program))\n  gl.deleteProgram(program)\n}\n\nexport const createProgramFromSources = (\n  gl: WebGL2RenderingContext,\n  sources: [string, string]\n): WebGLProgram => {\n  const [vert, frag] = sources\n  return createProgram(gl, [\n    createShader(gl, gl.VERTEX_SHADER, vert),\n    createShader(gl, gl.FRAGMENT_SHADER, frag),\n  ])\n}\n\nexport const showWebGLUnsupportedError = (parentElement: Element): void => {\n  const errorMessage = document.createElement('div')\n  errorMessage.className = 'error'\n  const p1 = document.createElement('p')\n  p1.appendChild(\n    document.createTextNode(\n      \"Sorry, your browser doesn't seem to support WebGL 2 :(\"\n    )\n  )\n  errorMessage.appendChild(p1)\n  const p2 = document.createElement('p')\n\n  p2.appendChild(\n    document.createTextNode('Try running in the latest Firefox or Chrome.')\n  )\n  errorMessage.appendChild(p2)\n  parentElement.appendChild(errorMessage)\n}\n","import vertexShaderSource from './shaders/helloworld.vert'\nimport fragmentShaderSource from './shaders/helloworld.frag'\nimport { createProgramFromSources, observeAndResizeCanvas } from './webglUtils'\n\n// Returns a random integer from 0 to range - 1\nconst randomInt = (range: number): number => Math.floor(Math.random() * range)\n\n// Fills the buffer with the values that define a rectangle.\nconst setRectangle = (\n  gl: WebGL2RenderingContext,\n  x: number,\n  y: number,\n  width: number,\n  height: number\n) => {\n  const x1 = x\n  const x2 = x + width\n  const y1 = y\n  const y2 = y + height\n\n  // NOTE: gl.bufferData(gl.ARRAY_BUFFER, ...) will affect\n  // whatever buffer is bound to the `ARRAY_BUFFER` bind point\n  // but so far we only have one buffer. If we had more than one\n  // buffer we'd want to bind that buffer to `ARRAY_BUFFER` first.\n  gl.bufferData(\n    gl.ARRAY_BUFFER,\n    new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]),\n    gl.STATIC_DRAW\n  )\n}\n\nconst main = () => {\n  // Get a WebGL 2 context\n  const canvas: HTMLCanvasElement = document.querySelector('#c')\n  const gl = canvas.getContext('webgl2')\n  if (!gl) {\n    console.error(\"Couldn't activate webgl2 context\")\n  }\n\n  // Lint the two shaders into a program\n  const program = createProgramFromSources(gl, [\n    vertexShaderSource,\n    fragmentShaderSource,\n  ])\n\n  // Look up where the vertex data needs to go\n  const positionAttributeLocation = gl.getAttribLocation(program, 'a_position')\n\n  // look up uniform locations\n  const resolutionUniformLocation = gl.getUniformLocation(\n    program,\n    'u_resolution'\n  )\n  const colorLocation = gl.getUniformLocation(program, 'u_color')\n\n  // Create a buffer and put three 2d clip space points in it\n  const positionBuffer = gl.createBuffer()\n\n  // Bind it to ARRAY_BUFFER\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)\n\n  // three 2d points\n  // const positions = [10, 20, 80, 20, 10, 30, 10, 30, 80, 20, 80, 30]\n  // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW)\n\n  // Create a vertex array object\n  const vao = gl.createVertexArray()\n\n  // and make it the one we're currently working with\n  gl.bindVertexArray(vao)\n\n  // turn it on\n  gl.enableVertexAttribArray(positionAttributeLocation)\n\n  // tell the attribute how to get data out of positionBuffer\n  const size = 2 // 2 components per iteration\n  const type = gl.FLOAT // the data is 32bit floats\n  const normalize = false // don't normalize the data\n  const stride = 0 // 0 = move forward size * sizeof(type) each iteration to get the next position\n  const offset = 0 // start at the beginning of the buffer\n  gl.vertexAttribPointer(\n    positionAttributeLocation,\n    size,\n    type,\n    normalize,\n    stride,\n    offset\n  )\n\n  // resize canvas\n  const resizer = observeAndResizeCanvas(gl.canvas, [300, 150])\n\n  const drawScene = () => {\n    resizer.resizeCanvasToDisplaySize()\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)\n\n    // Clear the canvas\n    gl.clearColor(0, 0, 0, 0)\n    gl.clear(gl.COLOR_BUFFER_BIT)\n\n    // Tell it to use our program (pair of shaders)\n    gl.useProgram(program)\n\n    // Bind the attribute/buffer set we want.\n    gl.bindVertexArray(vao)\n\n    // Pass in the canvas resolution so we can convert from pizels to clip space in the shader\n    gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height)\n\n    // draw\n    for (let i = 0; i < 50; ++i) {\n      // Setup a random rectangle\n      setRectangle(\n        gl,\n        randomInt(300),\n        randomInt(300),\n        randomInt(300),\n        randomInt(300)\n      )\n\n      // Set a random colour\n      gl.uniform4f(\n        colorLocation,\n        Math.random(),\n        Math.random(),\n        Math.random(),\n        1\n      )\n\n      // Draw the rectangle\n      const primitiveType = gl.TRIANGLES\n      const offset = 0\n      const count = 6\n      gl.drawArrays(primitiveType, offset, count)\n    }\n  }\n\n  requestAnimationFrame(drawScene)\n}\n\nmain()\n"],"names":["__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","createShader","gl","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","log","getShaderInfoLog","deleteShader","randomInt","range","Math","floor","random","setRectangle","x","y","width","height","x1","x2","y1","y2","bufferData","ARRAY_BUFFER","Float32Array","STATIC_DRAW","document","querySelector","getContext","error","program","sources","vert","frag","shaders","vertexShader","fragmentShader","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","VERTEX_SHADER","FRAGMENT_SHADER","createProgramFromSources","positionAttributeLocation","getAttribLocation","resolutionUniformLocation","getUniformLocation","colorLocation","positionBuffer","createBuffer","bindBuffer","vao","createVertexArray","bindVertexArray","enableVertexAttribArray","FLOAT","vertexAttribPointer","resizer","canvas","initialSize","canvasToDisplaySizeMap","Map","ResizeObserver","entries","entry","dpr","window","devicePixelRatio","devicePixelContentBoxSize","inlineSize","blockSize","contentBoxSize","contentRect","displayWidth","round","displayHeight","set","target","observe","box","resizeCanvasToDisplaySize","get","needResize","observeAndResizeCanvas","requestAnimationFrame","viewport","clearColor","clear","COLOR_BUFFER_BIT","useProgram","uniform2f","i","uniform4f","primitiveType","TRIANGLES","offset","count","drawArrays","main"],"sourceRoot":""}